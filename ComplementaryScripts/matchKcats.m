%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kcats = matchKcats(model_data, org_name,GECKO_path,keggPath)
% Matchs the model EC numbers and substrates to the BRENDA database, to
% return the corresponding kcats for each reaction.
%
% INPUT:    Model data structure (generated by getECnumbers.m)
% OUTPUTS:  kcats, which contains:
%           *forw.kcats:   kcat values for the forward reactions (mxn)
%           *forw.org_s:   Number of matches for organism - substrate in
%                          forward reaction (mxn)
%           *forw.rest_s:  Number of matches for any organism - substrate
%                          in forward reaction (mxn)
%           *forw.org_ns:  Number of matches for organism - any substrate
%                          in forward reaction (mxn)
%           *forw.rest_ns: Number of matches for any organism - any
%                          substrate in forward reaction (mxn)
%           *forw.org_sa:  Number of matches for organism - using s.a.
%                          in forward reaction (mxn)
%           *forw.rest_sa: Number of matches for any organism - using s.a.
%                          in forward reaction (mxn)
%           *back.kcats:   kcat values for the backward reactions (mxn)
%           *back.org_s:   Number of matches for organism - substrate in
%                          backwards reaction (mxn)
%           *back.rest_s:  Number of matches for any organism - substrate
%                          in backwards reaction (mxn)
%           *back.org_ns:  Number of matches for organism - any substrate
%                          in backwards reaction (mxn)
%           *back.rest_ns: Number of matches for any organism - any
%                          substrate in backwards reaction (mxn)
%           *back.org_sa:  Number of matches for organism - using s.a.
%                          in backwards reaction (mxn)
%           *back.rest_sa: Number of matches for any organism - using s.a.
%                          in backwards reaction (mxn)
%           *tot.queries:  The total amount of ECs matched (1x1)
%           *tot.org_s:    The amount of ECs matched for the organism & the
%                          substrate (1x1)
%           *tot.rest_s:   The amount of ECs matched for any organism & the
%                          substrate (1x1)
%           *tot.org_ns:   The amount of ECs matched for the organism & any
%                          substrate (1x1)
%           *tot.rest_ns:  The amount of ECs matched for any organism & any
%                          substrate (1x1)
%           *tot.org_sa:   The amount of ECs matched for the organism & 
%                          using s.a. (1x1)
%           *tot.rest_sa:  The amount of ECs matched for any organism & 
%                          using s.a. (1x1)
% 
% Benjam?n J. S?nchez. Last edited: 2016-03-01
% Ivan Domenzain.      Last edited: 2017-10-25
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function kcats = matchKcats(model_data, org_name,GECKO_path,keggPath)
    %Load BRENDA data:
    cd ../Databases/BRENDA_data
    kcat_file  = 'max_KCAT.txt';
    SA_file    = 'max_SA.txt';
    MW_file    = 'max_MW.txt';
    fID        = fopen(kcat_file);
    BRENDA     = textscan(fID,'%s %s %s %f  %s','delimiter','\t');
    BRENDA{4}  = BRENDA{4}*3600;   %[1/s] -> [1/h]
    fclose(fID);
    %Split string for each organism in the BRENDA data {name, taxonomy, KEGG code}
     BRENDA{3}  = cellfun(@stringSplit, BRENDA{3});
    %Creates a cell with all the SA*Mw values (corresponding to the same EC#
    %and organism).
    SA_cell    = SA_BRENDA(SA_file,MW_file);
    %Creates a Structure with KEGG codes for organisms, names and phylogenetic 
    %distance matrix and extract the organism index in the KEGG struct
    phylDistStruct =  KEGG_struct(true,keggPath);
    %phylDistStruct.names = transpose(phylDistStruct.names);
    org_index = find_inKEGG(org_name,phylDistStruct.names);
    cd ([GECKO_path '/Matlab_Module/get_enzyme_data'])
    %Extract relevant info from model_data:
    substrates = model_data.substrates;
    products   = model_data.products;
    EC_numbers = model_data.EC_numbers;
    model      = model_data.model;
    % %Create initially empty outputs:
    [mM,nM]      = size(EC_numbers);
    forw.kcats   = zeros(mM,nM);
    forw.org_s   = zeros(mM,nM);
    forw.rest_s  = zeros(mM,nM);
    forw.org_ns  = zeros(mM,nM);
    forw.rest_ns = zeros(mM,nM);
    forw.org_sa  = zeros(mM,nM);
    forw.rest_sa = zeros(mM,nM);
    back.kcats   = zeros(mM,nM);
    back.org_s   = zeros(mM,nM);
    back.rest_s  = zeros(mM,nM);
    back.org_ns  = zeros(mM,nM);
    back.rest_ns = zeros(mM,nM);
    back.org_sa  = zeros(mM,nM);
    back.rest_sa = zeros(mM,nM);
    tot.queries  = 0;
    tot.org_s    = 0;
    tot.rest_s   = 0;
    tot.org_ns   = 0;
    tot.rest_ns  = 0;
    tot.org_sa   = 0;
    tot.rest_sa  = 0;
    tot.wc0      = 0;
    tot.wc1      = 0;
    tot.wc2      = 0;
    tot.wc3      = 0;
    tot.wc4      = 0;
    tot.matrix   = zeros(6,5);

    %Main loop: 
     for i = 1:mM
        %Match:
        for j = 1:nM
            EC = EC_numbers{i,j};
            %Try to match direct reaction:
            if ~isempty(EC) && ~isempty(substrates{i,1})
                 [forw,tot] = iterativeMatch(EC,substrates(i,:),i,j,BRENDA,...
                   forw,tot,model,org_name,phylDistStruct,org_index,SA_cell);
            end
            %Repeat for inverse reaction:
            if ~isempty(EC) && ~isempty(products{i,1})
                [back,tot] = iterativeMatch(EC,products(i,:),i,j,BRENDA,...
                   back,tot,model,org_name,phylDistStruct,org_index,SA_cell);
            end
        end
        %Display progress:
        disp(['Matching kcats: Ready with rxn ' num2str(i)])
    end
    kcats.forw = forw;
    kcats.back = back;
    kcats.tot  = tot;

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [dir,tot] =iterativeMatch(EC,subs,i,j,BRENDA,dir,tot,model,...
                                   name,phylDistStruct,org_index,SA_cell)
%Will iteratively try to match the EC number to some registry in BRENDA,
%using each time one additional wildcard.
EC      = strsplit(EC,' ');
kcat    = zeros(size(EC));
origin  = zeros(size(EC));
matches = zeros(size(EC));
wc_num  = ones(size(EC)).*1000;
for k = 1:length(EC)
    success  = false;
    while ~success
        %Atempt match:
        [kcat(k),origin(k),matches(k)] = mainMatch(EC{k},subs,BRENDA,model,...
                                  i,name,phylDistStruct,org_index,SA_cell);
        %If any match found, ends. If not, introduces one extra wild card and
        %tries again:
        if origin(k) > 0
            success   = true;
            wc_num(k) = sum(EC{k}=='-');
        else
            dot_pos  = [2 strfind(EC{k},'.')];
            wild_num = sum(EC{k}=='-');
            wc_text  = '-.-.-.-';
            EC{k}    = [EC{k}(1:dot_pos(4-wild_num)) wc_text(1:2*wild_num+1)];
        end
    end
end

if sum(origin) > 0
    %For more than one EC: Choose the maximum value among the ones with the
    %less amount of wildcards and the better origin:
    best_pos   = (wc_num == min(wc_num));
    new_origin = origin(best_pos);
    best_pos   = (origin == min(new_origin(new_origin~=0)));
    max_pos    = find(kcat == max(kcat(best_pos)));
    wc_num     = wc_num(max_pos(1));
    origin     = origin(max_pos(1));
    matches    = matches(max_pos(1));
    kcat       = kcat(max_pos(1));
    
    %Update dir and tot:
    dir.kcats(i,j)   = kcat;
    dir.org_s(i,j)   = matches*(origin == 1);
    dir.rest_s(i,j)  = matches*(origin == 2);
    dir.org_ns(i,j)  = matches*(origin == 3);
    dir.org_sa(i,j)  = matches*(origin == 4);
    dir.rest_ns(i,j) = matches*(origin == 5);    
    dir.rest_sa(i,j) = matches*(origin == 6);
    tot.org_s        = tot.org_s   + (origin == 1);
    tot.rest_s       = tot.rest_s  + (origin == 2);
    tot.org_ns       = tot.org_ns  + (origin == 3);
    tot.org_sa       = tot.org_sa  + (origin == 4);
    tot.rest_ns      = tot.rest_ns + (origin == 5);    
    tot.rest_sa      = tot.rest_sa + (origin == 6);
    tot.wc0          = tot.wc0     + (wc_num == 0);
    tot.wc1          = tot.wc1     + (wc_num == 1);
    tot.wc2          = tot.wc2     + (wc_num == 2);
    tot.wc3          = tot.wc3     + (wc_num == 3);
    tot.wc4          = tot.wc4     + (wc_num == 4);
    tot.queries      = tot.queries + 1;
    tot.matrix(origin,wc_num+1) = tot.matrix(origin,wc_num+1) + 1;
end

end
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [kcat,origin,matches] = mainMatch(EC,subs,BRENDA,model,i,...
                                     name,phylDistStruct,org_index,SA_cell)
                                                                  
% Matching function prioritizing organism and substrate specificity when
% available.
origin = 0;
%First try to match organism and substrate:
%[kcat,matches] = matchKcat(EC,subs,BRENDA,true,true,model,i);
[kcat,matches] = matchKcat(EC,subs,BRENDA,name,true,false,model,i,...
                           phylDistStruct,org_index,SA_cell);
                                   
if matches > 0
    origin = 1;
%If no match, try any organism but match the substrate:
else
    [kcat,matches] = matchKcat(EC,subs,BRENDA,'',true,false,model,i,...
                               phylDistStruct,org_index,SA_cell);
    if matches > 0
        origin = 2;
    %If no match, try to match organism but with any substrate:
    else
        [kcat,matches] = matchKcat(EC,subs,BRENDA,name,false,false,model,i,...
                                   phylDistStruct,org_index,SA_cell);
        if matches > 0
            origin = 3;
        
        else
        % If no succes, then look for organism with SA*MW
             [kcat,matches] = matchKcat(EC,subs,BRENDA,name,false,true,...
                                  model,i,phylDistStruct,org_index,SA_cell);
             if matches > 0
                 origin = 4;     
             %If no match, try any organism and any substrate:
             else
                [kcat,matches] = matchKcat(EC,subs,BRENDA,'',false,false,...
                                 model,i,phylDistStruct,org_index,SA_cell);
                if matches > 0
                    origin = 5;
                %Again if no match, look for any org, SA*MW    
                 else
                     [kcat,matches] = matchKcat(EC,subs,BRENDA,'',false,...
                             true,model,i,phylDistStruct,org_index,SA_cell);
                     if matches > 0
                         origin = 6;
                     end
                end
                        
             end    
        end
    end
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [kcat,matches] = matchKcat(EC,subs,BRENDA,organism,...
                     substrate,SA,model,i,phylDistStruct,org_index,SA_cell)
                 
%Will go through BRENDA and will record any match. Afterwards, it will
%return the average value and the number of matches attained.
kcat    = [];
matches = 0;
%Relaxes matching if wild cards are present:
wild     = false;
wild_pos = strfind(EC,'-');
if ~isempty(wild_pos)
    EC   = EC(1:wild_pos(1)-1);
    wild = true;
end

if SA
    EC_indexes = extract_indexes(EC,SA_cell{1},[],SA_cell{2},subs,substrate,...
                                 organism,org_index,phylDistStruct);
    kcat       = SA_cell{3}(EC_indexes);
else
    EC_indexes = extract_indexes(EC,BRENDA{1},BRENDA{2},BRENDA{3},subs,substrate,...
                                 organism,org_index,phylDistStruct);
    if substrate
        for j = 1:length(EC_indexes)
            indx = EC_indexes(j);
            for k = 1:length(subs)
                l = boolean(strcmpi(model.metNames,subs{k}).*(model.S(:,i)~=0));
                if ~isempty(subs{k}) && strcmpi(subs{k},BRENDA{2}(indx))
                    if BRENDA{4}(indx) > 0 
                        coeff = min(abs(model.S(l,i)));
                        kcat  = [kcat;BRENDA{4}(indx)/coeff];
                    end
                end
            end
        end
    else
        kcat = BRENDA{4}(EC_indexes);
    end
end                         
%Return maximum value:
if isempty(kcat)
    kcat = 0;
else
    matches = length(kcat);
    kcat    = max(kcat);
end
% 
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Extract the indexes of the entries in the BRENDA data that meet the 
%conditions specified by the search criteria
function EC_indexes = extract_indexes(EC,EC_cell,subs_cell,orgs_cell,subs,...
                              substrate,organism, org_index,phylDistStruct)

                          
EC_indexes = [];                          
for j=1:length(EC_cell)
    if strfind(EC_cell{j},EC)==1
        EC_indexes = [EC_indexes,j];
    end
end
%If substrate=true then it will extract only the substrates appereances 
%indexes in the EC subset from the BRENDA cell array
if substrate
    Subs_indexes = [];
    for l = 1:length(subs)
        if ~isempty(subs(l))
            Subs_indexes = horzcat(Subs_indexes,EC_indexes(strcmpi(subs(l),...
                                    subs_cell(EC_indexes))));          
        end
    end
    EC_indexes = Subs_indexes;    
end

EC_orgs = orgs_cell(EC_indexes);
%If specific organism values are requested looks for all the organism
%repetitions on the subset BRENDA cell array(EC_indexes)
if string(organism) ~= ''  
    EC_indexes = EC_indexes(strcmpi(string(organism),EC_orgs));

%If KEGG code was assigned to the organism (model) then it will look for   
%the Kcat value for the closest organism
elseif org_index~='*' %&& org_index~=''
    KEGG_indexes = [];temp = [];  
    %For relate a phyl dist between the modelled organism and the organisms
    %on the BRENDA cell array it should search for a KEGG code for each of these 
    for j=1:length(EC_indexes)
        %Assigns a KEGG index to orgs those found on the KEGG struct
        orgs_index = find(strcmpi(orgs_cell(EC_indexes(j)),phylDistStruct.names),1);
        if ~isempty(orgs_index)
            KEGG_indexes = [KEGG_indexes; orgs_index];
            temp         = [temp;EC_indexes(j)];
        %For values related to organisms without KEGG code, then it will
        %look for KEGG code for the first organism with the same genus
        else
            k=1;
            while isempty(orgs_index) && k<length(phylDistStruct.names)
                str = phylDistStruct.names{k};
                org = orgs_cell{EC_indexes(j)};
                if strcmpi(org(1:strfind(org,' ')-1), str(1:strfind(str,' ')-1))
                    orgs_index = k;KEGG_indexes = [KEGG_indexes;k];
                    temp       = [temp;EC_indexes(j)];
                end
                k = k+1;
            end
        end
    end
    %Update the EC_indexes cell array
    EC_indexes = temp;
    %Looks for the phylogenetically closest organism and saves the index of
    %its appearences in the BRENDA cell
    if ~isempty(EC_indexes)
        distances  = num2cell(phylDistStruct.distMat(org_index,:));
        distances  = distances(KEGG_indexes);
        EC_indexes = EC_indexes(cell2mat(distances) ==...
                                min(cell2mat(distances)));                     
    end
end

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function string_cells = stringSplit(cell_array)

        string_cells = {strsplit(cell_array,'//')};
        string_cells = string_cells{1}(1);

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function org_index = find_inKEGG(org_name,names)

    org_index      = find(strcmpi(org_name,names));
    if isempty(org_index)
        i=1;
        while isempty(org_index) && i<length(names)
            str = names{i};
            if strcmpi(org_name(1:strfind(org_name,' ')-1),...
                str(1:strfind(str,' ')-1))
                org_index = i;
            end
            i = i+1;
        end
        if isempty(org_index);org_index = '*';end
    end
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function phylDistStruct =  KEGG_struct(unicellular,keggPath)

    cd ../../ComplementaryScripts
    phylDistStruct       = UpdatePhylDist_(keggPath,unicellular);
    phylDistStruct.ids   = transpose(phylDistStruct.ids);
    phylDistStruct.names = transpose(phylDistStruct.names);
    
    for i=1:length(phylDistStruct.names)
        pos = strfind(phylDistStruct.names{i}, ' (');
        if ~isempty(pos)
            phylDistStruct.names{i} = phylDistStruct.names{i}(1:pos-1);
        end
    end
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function SA_cell = SA_BRENDA(SA_file,MW_file )

    fID   = fopen(SA_file);
    SA    = textscan(fID,'%s %s %s %f  %s','delimiter','\t');
    SA{4} = SA{4};   
    fclose(fID);

    fID   = fopen(MW_file);
    MW    = textscan(fID,'%s %s %s %f  %s','delimiter','\t');
    MW{4} = MW{4};   
    fclose(fID);
    
    SA{3}   = cellfun(@stringSplit, SA{3});
    MW{3}   = cellfun(@stringSplit, MW{3});
    for i=1:3
        SA_cell{i} = [];
    end
    previousEC = []; EC_indexes = [];
    for i=1:length(SA{1})
        %Gets the indexes of the EC repetitions in the MW cell for every
        %new (different) EC
        if ~strcmpi(SA{1}(i), previousEC)
            %EC_indexes = indexes_string(MW{1},SA{1}{i},false);
            EC_indexes = find(strcmpi(SA{1}(i),MW{1}));
        end
        % just looks for the first match because just the maximal value for
        % each EC# / Orgaism is reported on the file
        mwEC{1} = MW{3}(EC_indexes); mwEC{2} = MW{4}(EC_indexes);
        %org_index = indexes_string(mwEC{1},SA{3}{i},true);
        org_index = find(strcmpi(SA{3}(i),mwEC{1}),1);
        if ~isempty(org_index)
            SA_cell{1} = [SA_cell{1};SA{1}(i)];
            SA_cell{2} = [SA_cell{2};SA{3}(i)];
            value      = SA{4}(i)* mwEC{2}(org_index)*(60/1000); %[1/hr]
            SA_cell{3} = [SA_cell{3}; value];
        end
        previousEC = SA{1}(i);
    end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




